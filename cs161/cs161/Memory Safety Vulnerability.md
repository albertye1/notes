*top Rust advertisement, besides the femboys*
# Attack Strategies
## Overflowing Buffer
* C has no conception of array length
* If you allow an attacker to start writing @ some location and don't specify stop location, they can overwrite other parts of memory
### Stack Smashing
*the stack deserved it*
* Occurs on stack memory; when returning from a prog, the `eip` is set to the `rip` saved on the stack
* This lets an attacker choose an address to jump to
Consider the following code:
```c
void vulnerable(void) {
	char poop[5];
	gets(poop);
}
```
Then, `poop` is stored right below the `sfp` and `rip`, so writing `13` characters instead will get you to the `rip`!
* Store some malicious **shellcode** in some address.
	* This shellcode will run something different from intended
	* Depending on length, you can put the shellcode either in `poop`/`sfp`, or after `rip`. 
* Put garbage into (remainder of) `poop` and `sfp`, so that you can then put the shellcode address into `rip`.
### Memory-Safe Code
*gustavo fring*
First, we try to malloc the string instead. This gives us the following code
```c
void maybe_vulnerable(void) {
	char* text = malloc(20);
	gets(text);
}
```
This is still insecure, because heap overflows are similarly bad.

However, we can specify the sive:
```c
void less_vulnerable(void) {
	char text[20];
	fgets(name, 20, stdin);
}
```
The length parameter specifies size of the buffer and will refuse to write any more bytes
* Vulnerable C functions:
	* `gets` - read string from stdin.
		* use `fgets` instead
	* `strcpy` - copy a string
		* use `strncpy`
		* or `strlcpy` for more safety but less compatibility
	* `strlen` - gets the length of a string
		* use `strnlen`
		* or `memchr` if compatibility needed
	* and more because C is a garbage language
### Signed/Unsigned Vulnerabilities
* If you still want to read something w/ variable length:
* You might've considered
```c
void func(int len, char *data) {
	char buf[64];
	if (len > 64)
		return; // try to not overflow
	// otherwise copy
	memcpy(buf, data, len);
}
```
When you say `len > 64` here, you are making a **signed comparison**. The issue here is that `len > 64` will be false if you set `len = -1`, but then it'll get casted over to unsigned when you do `memcpy`. Therefore, you should do:
```c
void better(size_t len, char *data) {
	char buf[64];
	if (len > 64)
		return; // try to not overflow
	// otherwise copy
	memcpy(buf, data, len);
}
```
Similar things can happen on the heap too.
```c
void func(size_t len, char *data) {
    char *buf = malloc(len + 2);
    if (!buf)
        return;
    memcpy(buf, data, len);
    buf[len] = '\n';
    buf[len + 1] = '\0';
}
```
Consider here the case where `len = 0xffffffff` (-1)
```c
void safe(size_t len, char *data) {  
    if (len > SIZE_MAX - 2)
        return;
    char *buf = malloc(len + 2);
    if (!buf)
        return;
    memcpy(buf, data, len);
    buf[len] = '\n';
    buf[len + 1] = '\0';
}
```
## Format String Vulnerability

^d13a15

*why can't i replicate this locally?*
* Normally, when you `printf` and include any flags in the format string, the `printf` is going to accept some memory afterwards.
* However, if there are false flags (for example, `printf("%d\n");`) C will still try to find a value in the stack
	* This will then overflow and allow us to access other variables in the stack. 
	* Will be useful later for like stack canary overwriting
* Also can use `%n`, which treats the next argument as a pointer. 
# Defense Strategies
## Stack Canary
* Put some value(s) onto the stack that shouldn't be modified. Then, check if they're the same at the end.
* Only issue is that we can use multiple ways (guessing, finding value) to get through the stack canary.
	* Such as [[#^d13a15]] above.