*top Rust advertisement, besides the femboys*
# Attack Strategies
## Overflowing Buffer
* C has no conception of array length
* If you allow an attacker to start writing @ some location and don't specify stop location, they can overwrite other parts of memory
### Stack Smashing
*the stack deserved it*
* Occurs on stack memory; when returning from a prog, the `eip` is set to the `rip` saved on the stack
* This lets an attacker choose an address to jump to
Consider the following code:
```c
void vulnerable(void) {
	char poop[5];
	gets(poop);
}
```
Then, `poop` is stored right below the `sfp` and `rip`, so writing `13` characters instead will get you to the `rip`!
* Store some malicious **shellcode** in some address.
	* This shellcode will run something different from intended
	* Depending on length, you can put the shellcode either in `poop`/`sfp`, or after `rip`. 
* Put garbage into (remainder of) `poop` and `sfp`, so that you can then put the shellcode address into `rip`.
### Memory-Safe Code
*gustavo fring*
First, we try to malloc the string instead. This gives us the following code
```c
void maybe_vulnerable(void) {
	char* text = malloc(20);
	gets(text);
}
```
This is still insecure, because heap overflows are similarly bad.

However, we can specify the sive:
```c
void less_vulnerable(void) {
	char text[20];
	fgets(name, 20, stdin);
}
```
The length parameter specifies size of the buffer and will refuse to write any more bytes
* Vulnerable C functions:
	* `gets` - read string from stdin.
		* use `fgets` instead
	* `strcpy` - copy a string
		* use `strncpy`
		* or `strlcpy` for more safety but less compatibility
	* `strlen` - gets the length of a string
		* use `strnlen`
		* or `memchr` if compatibility needed
	* and more because C is a garbage language
### Signed/Unsigned Vulnerabilities
* If you still want to read something w/ variable length:
* You might've considered
```c
void func(int len, char *data) {
	char buf[64];
	if (len > 64)
		return; // try to not overflow
	// otherwise copy
	memcpy(buf, data, len);
}
```
When you say `len > 64` here, you are making a **signed comparison**. The issue here is that `len > 64` will be false if you set `len = -1`, but then it'll get casted over to unsigned when you do `memcpy`. Therefore, you should do:
```c
void better(size_t len, char *data) {
	char buf[64];
	if (len > 64)
		return; // try to not overflow
	// otherwise copy
	memcpy(buf, data, len);
}
```
Similar things can happen on the heap too.
```c
void func(size_t len, char *data) {
Â Â Â Â char *buf = malloc(len + 2);
Â Â Â Â if (!buf)
Â Â Â Â Â Â Â Â return;
Â Â Â Â memcpy(buf, data, len);
Â Â Â Â buf[len] = '\n';
Â Â Â Â buf[len + 1] = '\0';
}
```
Consider here the case where `len = 0xffffffff` (-1)
```c
void safe(size_t len, char *data) {  
Â  Â  if (len > SIZE_MAX - 2)
Â Â Â Â Â Â Â Â return;
Â Â Â Â char *buf = malloc(len + 2);
Â Â Â Â if (!buf)
Â Â Â Â Â Â Â Â return;
Â Â Â Â memcpy(buf, data, len);
Â Â Â Â buf[len] = '\n';
Â Â Â Â buf[len + 1] = '\0';
}
```
## Format String Vulnerability

^d13a15

*why can't i replicate this locally?*
* Normally, when you `printf` and include any flags in the format string, the `printf` is going to accept some memory afterwards.
* However, if there are false flags (for example, `printf("%d\n");`) C will still try to find a value in the stack
	* This will then overflow and allow us to access other variables in the stack. 
	* Will be useful later for like stack canary overwriting
* Also can use `%n`, which treats the next argument as a pointer. 
## NOP Sleds
*weeeeee*
Instead of having to jump to an exact address, make it "close enough" s.t. small shifts don't break the exploit
* `nop`: only advances `eip`

Chaining a long sequence of `nop`s means that landing at any `nop` moves you to the next address, which is shellcode. Wheeeeeeeeeeee
# Defense Strategies
The idea is to crash whenever something bad happens, instead of letting the attacker do stuff
## Non-Executable Pages
* Try to stop the shellcode from actually running
* Idea: Most programs don't need memory that is both written to and executed
	* So, we can make some parts of the memory **either** exec'able **or** writeable
	* Stack, heap, static data: writeable but not execable
	* Code: execable, but not writeable
* Page table entries have a writeable bit and an execable bit that can be set to achieve this behavior
	* Recall page tables convert virtuall addresses into physical addresses.
	* Impl'd oni hardware, so effectively no overhead
* Also known as
	* W^X (write xor execute)
	* DEP (data execution prevention)
### Subversion
* NEP's don't prevent an attacker from leveraging **existing** code
* Most programs have many functions in memory that can be used maliciously
	* **return-to-libc**
		* Per the x86 calling convention, each program expects args to be placed above `rip`.
		* Consider the `system` function, which executes a shell command. We want to execute like: `system("bad cmd")`
		* So put our 
	* **return-oriented programming
		* instead of executing an existing function, execute your own cod eby executing different pieces of different code
		* **gadget**: small set of asm instructions that already exist in memory
			* Usually end in `ret` instruction
			* Usually **not** full functions
		* ROP strategy is to write a chain of return addresses starting at `rip` to achieve desired behavior
			* So each return address points to a gadget, which executes its instructions and ends w/ another `ret` instruction
		* If the code base is big enough, there are usually enough gadgets in memory to run any desired shellcode
## Stack Canary
* Put some value(s) onto the stack that shouldn't be modified. Then, check if they're the same at the end.
	* Value is unique every time program is run, but same for all functions within a run
	* A canary value uses `NULL` as its first byte to mitigate string-based attacks, like: [[Memory Safety Vulnerability#^d13a15]]. 
	* Put right below `rip` and `sfp` and right above all local variables, so that if someone writes from local and adds to `rip`, something bad will happen
* Efficiency
	* More overhead; in almost all applications, impact isn't big
### Subversion
* **leak** canary: overwrite value with itself
* **bypass** canary: use a random write, not a sequential write
* **guess** canary: brute force
## Pointer Authentication
### 32, 64
* 32-bit can access $2^{32}$B = 4GB of memory
* But 64-bit can access $2^{64}$B = 18 billion GB of memory
* At most 42 bits are needed, so 22 bits left unused.
### So, the idea:
* Instead of placing secret value below the pointer, store a value in the pointer itself
* Use the unused bits in a 64-bit address to store value
* When storing in memory, replace unused bits w/ **pointer auth code (PAC)**
* Before using pointer in memory, check if PAC is valid
	* If PAC invalid, crash the program
	* If PAC valid, restore unused bits and use the address normally
* Each address has own PAC, and only someone who knows CPU's master secret can generate a PAC for an address
	* Leaking memory won't leak the master secret
### Subversion
* learn master secret
* guess a PAC
* pointer reuse

Pointer auth is now supported by ARM!! ðŸŽ‰ðŸŽ‰ðŸŽ‰
## ASLR
* An attacker inserts malicious shellcode at a known memory address
	* Mitigation: Address space layout randomization
* Peyrin has been gaslighting me for weeks
	* In practice, memory is mostly empty!
	* So, put each segment of memory in a different location on each run
* ASLR can shuffle all 4 segments of memory
	* Stack: Canâ€™t place shellcode on the stack without knowing the address of the stack
	* Heap: Canâ€™t place shellcode on the heap without knowing the address of the heap
	* Code: Canâ€™t construct a ROP chain or return-to-libc attack without knowing the address of code
* Efficiency
	* No overhead. Because we need to dynamically link libraries anyways, so we have to move things around anyways
### Subversion
* Leak address of a pointer, whose address relative to shellcode is known
	* Relative addr's are usually  fixed, so this is sufficient to undo randomization
	* Leak a stack pointer -> leak the location of the stack
	* Leak a `rip` -> leak the location of the caller
* Guess the address of your shellcode: Brute-force
	* Don't do it on project 1 LOL
## Combining Mitigations
* We can use multiple mitigations together
* Example: Combining ASLR and non-executable pages
* To defeat both, the attacker needs to find two vulnerabilities
	* First, find a way to leak memory and reveal the address randomization (defeat ASLR)
	- Second, find a way to write to memory and write a ROP chain (defeat non-executable pages)
* mitigations must be enabled.